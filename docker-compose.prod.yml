version: '3.8'

# --- Production Docker Compose Configuration ---
# Instructions for Scalability:
# 1. Database (PostgreSQL):
#    - For High Availability, use a managed service (AWS RDS, Google Cloud SQL) or deploy a Primary-Replica cluster (e.g., using Bitnami PostgreSQL with Repmgr).
#    - Set DATABASE_URL in .env to point to the connection pooler (e.g., PgBouncer) or the primary instance.
# 2. Redis:
#    - Use Redis Sentinel or Cluster for failover. Update REDIS_HOST/REDIS_PORT accordingly.
# 3. Load Balancing:
#    - Deploy behind Nginx or Traefik. Only expose ports 80/443.
#    - Run multiple instances of 'backend' and 'crawler' and 'js_renderer' as needed.

services:
  # In production, we often skip hosting DB/Redis inside Docker Compose if using Managed Services.
  # However, for a self-hosted single-node production setup, this configuration is hardened.

  postgres:
    image: postgres:16-alpine
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    # No ports exposed to host
    networks:
      - teaser_net
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    restart: always
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - teaser_net

  minio:
    image: quay.io/minio/minio:latest
    restart: always
    command: minio server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY}
      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY}
    volumes:
      - minio_data:/data
    networks:
      - teaser_net
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

  meilisearch:
    image: getmeili/meilisearch:latest
    restart: always
    environment:
      MEILI_MASTER_KEY: ${MEILI_MASTER_KEY}
      MEILI_ENV: "production"
      MEILI_NO_ANALYTICS: "true"
    volumes:
      - meili_data:/meili_data
    networks:
      - teaser_net
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:7700/health"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build: 
      context: ./go-backend
      dockerfile: Dockerfile
    restart: always
    environment:
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      REDIS_HOST: redis:6379
      MINIO_ENDPOINT: minio:9000
      MINIO_ACCESS_KEY: ${MINIO_ACCESS_KEY}
      MINIO_SECRET_KEY: ${MINIO_SECRET_KEY}
      ADMIN_PASSWORD: ${ADMIN_PASSWORD}
      MEILI_HOST: http://meilisearch:7700
      MEILI_API_KEY: ${MEILI_MASTER_KEY}
    volumes:
      - crawler_config:/app/crawler
    networks:
      - teaser_net
    # In production, use a reverse proxy to map this to an external port/domain
    # expose:
    #   - "8080"

  crawler:
    build: 
      context: . 
      dockerfile: Dockerfile.Crawler
    restart: always
    environment:
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      MINIO_ENDPOINT: minio:9000
      MINIO_ACCESS_KEY: ${MINIO_ACCESS_KEY}
      MINIO_SECRET_KEY: ${MINIO_SECRET_KEY}
    volumes:
      - crawler_config:/app/crawler
    networks:
      - teaser_net

  indexer_worker:
    build:
      context: .
      dockerfile: indexer/Dockerfile.Indexer
    restart: always
    environment:
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      MEILI_HOST: http://meilisearch:7700
      MEILI_API_KEY: ${MEILI_MASTER_KEY}
    depends_on:
      postgres:
        condition: service_healthy
      meilisearch:
        condition: service_healthy
    networks:
      - teaser_net

  dashboard:
    build:
      context: ./dashboard-frontend
      dockerfile: Dockerfile
    restart: always
    networks:
      - teaser_net
    environment:
      - NEXT_PUBLIC_API_BASE_URL=${API_BASE_URL} # Must be set to public URL in prod
    # expose:
    #   - "3000"

  lith_ranker:
    build:
      context: ./lith-ranker
      dockerfile: Dockerfile
    restart: always
    environment:
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      LITH_INTERVAL_MINUTES: 60
      LITH_MAX_ITERATIONS: 20
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - teaser_net

  js_renderer:
    build:
      context: ./js-renderer
      dockerfile: Dockerfile
    restart: always
    networks:
      - teaser_net

volumes:
  postgres_data:
  minio_data:
  meili_data:
  redis_data:
  crawler_config:

networks:
  teaser_net:
    driver: bridge
